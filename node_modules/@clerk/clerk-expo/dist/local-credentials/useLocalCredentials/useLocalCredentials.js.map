{"version":3,"sources":["../../../src/local-credentials/useLocalCredentials/useLocalCredentials.ts"],"sourcesContent":["import { useClerk, useSignIn, useUser } from '@clerk/clerk-react';\nimport type { SignInResource } from '@clerk/types';\nimport { AuthenticationType, isEnrolledAsync, supportedAuthenticationTypesAsync } from 'expo-local-authentication';\nimport {\n  deleteItemAsync,\n  getItem,\n  getItemAsync,\n  setItemAsync,\n  WHEN_PASSCODE_SET_THIS_DEVICE_ONLY,\n} from 'expo-secure-store';\nimport { useEffect, useState } from 'react';\n\nimport { errorThrower } from '../../utils';\nimport type { BiometricType, LocalCredentials, LocalCredentialsReturn } from './shared';\n\nconst useEnrolledBiometric = () => {\n  const [isEnrolled, setIsEnrolled] = useState(false);\n\n  useEffect(() => {\n    let ignore = false;\n\n    void isEnrolledAsync().then(res => {\n      if (ignore) {\n        return;\n      }\n      setIsEnrolled(res);\n    });\n\n    return () => {\n      ignore = true;\n    };\n  }, []);\n\n  return isEnrolled;\n};\n\nconst useAuthenticationType = () => {\n  const [authenticationType, setAuthenticationType] = useState<BiometricType | null>(null);\n\n  useEffect(() => {\n    let ignore = false;\n\n    void supportedAuthenticationTypesAsync().then(numericTypes => {\n      if (ignore) {\n        return;\n      }\n      if (numericTypes.length === 0) {\n        return;\n      }\n\n      if (\n        numericTypes.includes(AuthenticationType.IRIS) ||\n        numericTypes.includes(AuthenticationType.FACIAL_RECOGNITION)\n      ) {\n        setAuthenticationType('face-recognition');\n      } else {\n        setAuthenticationType('fingerprint');\n      }\n    });\n\n    return () => {\n      ignore = true;\n    };\n  }, []);\n\n  return authenticationType;\n};\n\nconst useUserOwnsCredentials = ({ storeKey }: { storeKey: string }) => {\n  const { user } = useUser();\n  const [userOwnsCredentials, setUserOwnsCredentials] = useState(false);\n\n  const getUserCredentials = (storedIdentifier: string | null): boolean => {\n    if (!user || !storedIdentifier) {\n      return false;\n    }\n\n    const identifiers = [\n      user.emailAddresses.map(e => e.emailAddress),\n      user.phoneNumbers.map(p => p.phoneNumber),\n    ].flat();\n\n    if (user.username) {\n      identifiers.push(user.username);\n    }\n    return identifiers.includes(storedIdentifier);\n  };\n\n  useEffect(() => {\n    let ignore = false;\n    getItemAsync(storeKey)\n      .catch(() => null)\n      .then(res => {\n        if (ignore) {\n          return;\n        }\n        setUserOwnsCredentials(getUserCredentials(res));\n      });\n\n    return () => {\n      ignore = true;\n    };\n  }, [storeKey, user]);\n\n  return [userOwnsCredentials, setUserOwnsCredentials] as const;\n};\n\n/**\n * Exposes utilities that allow for storing and accessing an identifier, and it's password securely on the device.\n * In order to access the stored credentials, the end user will be prompted to verify themselves via biometrics.\n */\nexport const useLocalCredentials = (): LocalCredentialsReturn => {\n  const { isLoaded, signIn } = useSignIn();\n  const { publishableKey } = useClerk();\n\n  const key = `__clerk_local_auth_${publishableKey}_identifier`;\n  const pkey = `__clerk_local_auth_${publishableKey}_password`;\n  const [hasLocalAuthCredentials, setHasLocalAuthCredentials] = useState(!!getItem(key));\n  const [userOwnsCredentials, setUserOwnsCredentials] = useUserOwnsCredentials({ storeKey: key });\n  const hasEnrolledBiometric = useEnrolledBiometric();\n  const authenticationType = useAuthenticationType();\n\n  const biometricType = hasEnrolledBiometric ? authenticationType : null;\n\n  const setCredentials = async (creds: LocalCredentials) => {\n    if (!(await isEnrolledAsync())) {\n      return;\n    }\n\n    if (creds.identifier && !creds.password) {\n      return errorThrower.throw(\n        `useLocalCredentials: setCredentials() A password is required when specifying an identifier.`,\n      );\n    }\n\n    if (creds.identifier) {\n      await setItemAsync(key, creds.identifier);\n    }\n\n    const storedIdentifier = await getItemAsync(key).catch(() => null);\n\n    if (!storedIdentifier) {\n      return errorThrower.throw(\n        `useLocalCredentials: setCredentials() an identifier should already be set in order to update its password.`,\n      );\n    }\n\n    setHasLocalAuthCredentials(true);\n    await setItemAsync(pkey, creds.password, {\n      keychainAccessible: WHEN_PASSCODE_SET_THIS_DEVICE_ONLY,\n      requireAuthentication: true,\n    });\n  };\n\n  const clearCredentials = async () => {\n    await Promise.all([deleteItemAsync(key), deleteItemAsync(pkey)]);\n    setHasLocalAuthCredentials(false);\n    setUserOwnsCredentials(false);\n  };\n\n  const authenticate = async (): Promise<SignInResource> => {\n    if (!isLoaded) {\n      return errorThrower.throw(\n        `useLocalCredentials: authenticate() Clerk has not loaded yet. Wait for clerk to load before calling this function`,\n      );\n    }\n    const identifier = await getItemAsync(key).catch(() => null);\n    if (!identifier) {\n      return errorThrower.throw(`useLocalCredentials: authenticate() the identifier could not be found`);\n    }\n    const password = await getItemAsync(pkey).catch(() => null);\n\n    if (!password) {\n      return errorThrower.throw(`useLocalCredentials: authenticate() cannot retrieve a password for ${identifier}`);\n    }\n\n    return signIn.create({\n      strategy: 'password',\n      identifier,\n      password,\n    });\n  };\n\n  return {\n    /**\n     * Stores the provided credentials on the device if the device has enrolled biometrics.\n     * The end user needs to have a passcode set in order for the credentials to be stored, and those credentials will be removed if the passcode gets removed.\n     * @param credentials A [`LocalCredentials`](#localcredentials) object.\n     * @return A promise that will reject if value cannot be stored on the device.\n     */\n    setCredentials,\n    /**\n     * A Boolean that indicates if there are any credentials stored on the device.\n     */\n    hasCredentials: hasLocalAuthCredentials,\n    /**\n     * A Boolean that indicates if the stored credentials belong to the signed in uer. When there is no signed-in user the value will always be `false`.\n     */\n    userOwnsCredentials,\n    /**\n     * Removes the stored credentials from the device.\n     * @return A promise that will reject if value cannot be deleted from the device.\n     */\n    clearCredentials,\n    /**\n     * Attempts to read the stored credentials and creates a sign in attempt with the password strategy.\n     * @return A promise with a SignInResource if the stored credentials were accessed, otherwise the promise will reject.\n     */\n    authenticate,\n    /**\n     * Indicates the supported enrolled biometric authenticator type.\n     * Can be `facial-recognition`, `fingerprint` or null.\n     */\n    biometricType,\n  };\n};\n"],"mappings":"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","names":[]}